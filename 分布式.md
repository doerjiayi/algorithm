#微服务

##服务降级、熔断、限流、排队
https://www.jianshu.com/p/33f394c0ee2d

##tars
https://blog.csdn.net/shuishishuideyingzi/article/details/89460973
https://www.cnblogs.com/lidabo/p/9122132.html
https://www.cnblogs.com/qwangxiao/p/11248817.html
https://blog.csdn.net/u014520797/article/details/80877639
https://www.liangzl.com/get-article-detail-18305.html
安装
https://blog.csdn.net/sunshine1314/article/details/81151080
https://blog.csdn.net/qq_40477151/article/details/81166838

源码
https://cloud.tencent.com/developer/article/1381515
https://cloud.tencent.com/developer/article/1381523?from=10680

https://cloud.tencent.com/developer/article/1394046
设计
https://www.jianshu.com/p/cfb778c452cd

##libco
https://www.cnblogs.com/dearplain/p/9820913.html
https://blog.csdn.net/u011579138/article/details/81839840
https://blog.csdn.net/zimengyu2020/article/details/80217499

##brpc

https://github.com/apache/incubator-brpc/blob/master/docs/cn/getting_started.md
https://cloud.tencent.com/developer/article/1383845
https://gitee.com/mirrors/BRPC


##grpc
https://blog.csdn.net/weiwangchao_/article/details/82023191
https://www.cnblogs.com/TianFang/p/4355280.html

##thrift
https://blog.csdn.net/zkp_java/article/details/81879577
https://blog.csdn.net/jek123456/article/details/53395206
https://www.jianshu.com/p/cf91da1e3f8d

##aba
https://blog.csdn.net/qq_42576040/article/details/88240595

##zookeeper
https://www.w3cschool.cn/zookeeper/zookeeper_cli.html
https://www.w3cschool.cn/zookeeper/zookeeper_overview.html
zookeeper快速入门——简介
https://cloud.tencent.com/developer/article/1383764

##eureka
https://blog.csdn.net/rubbertree/article/details/95085507
https://blog.csdn.net/tianyaleixiaowu/article/details/78192922
https://www.cnblogs.com/demodashi/p/8509931.html
https://www.cnblogs.com/feixiangdecainiao/p/10850558.html
https://www.jianshu.com/p/c18db3a2efc6

##zab
https://www.cnblogs.com/crazylqy/p/7132133.html
https://www.cnblogs.com/crazylqy/p/7132369.html
https://www.imooc.com/article/260128

##调用链
https://www.jianshu.com/p/da80ea881424

##灰度 共享内存
https://my.oschina.net/izhangll/blog/884713

##keepalived
https://blog.51cto.com/superpcm/2095395

##微服务设计
https://book.douban.com/subject/26772677/

##大型分布式系统的优化解决方案
https://blog.csdn.net/xiaopy_0508/article/details/78190102


##《亿级流量网站架构核心技术》概要
https://www.cnblogs.com/jstarseven/p/9174604.html


## 可伸缩服务架构
《可伸缩服务架构 框架与中间件》综合（1）
https://blog.csdn.net/u011692924/article/details/81938019
《可伸缩服务架构 框架与中间件》综合（2）
https://blog.csdn.net/u011692924/article/details/81938235
《可伸缩服务架构 框架与中间件》综合（3）
https://blog.csdn.net/u011692924/article/details/82988759
《可伸缩服务架构 框架与中间件》综合（4）
https://blog.csdn.net/u011692924/article/details/82989820

分库分表的架构设计—《可伸缩服务架构》
https://blog.csdn.net/ok449a6x1i6qq0g660fV/article/details/80193375


#消息中间件
##kafka
https://github.com/wurstmeister/kafka-docker

##rabbit mq
https://github.com/alanxz/rabbitmq-c
https://www.cnblogs.com/knowledgesea/p/6535766.html
https://www.jianshu.com/p/6376936845ff
https://pdf.us/2018/06/07/1260.html
https://blog.csdn.net/jinyidong/article/details/80003362
https://pdf.us/2018/06/12/1311.html

https://blog.csdn.net/hellozpc/article/details/81436980#83Topic_Exchange_1429
https://www.cnblogs.com/ysocean/p/9251884.html

RabbitMQ教程
https://blog.csdn.net/hellozpc/article/details/81436980

RabbitMQ镜像队列的故障恢复
http://www.360doc.com/content/15/0312/15/20874412_454584335.shtml

rabbitMq集群之镜像模式
https://blog.csdn.net/wexiaoword/article/details/81352045

消息中间件面试题：消息队列的优缺点，区别
https://blog.csdn.net/Iperishing/article/details/86674084

##消息中间件（一）MQ详解及四大MQ比较
https://blog.csdn.net/wqc19920906/article/details/82193316


#调用链
##[cat]https://github.com/dianping/cat/
##[GRPC java 分布式调用链跟踪实践]https://www.jianshu.com/p/2ec0f8d4ae3d

#网络库
##libev
libev学习（一） https://www.cnblogs.com/qigaohua/p/5883400.html
   bool ev_run (struct ev_loop *loop, int flags);
初始化 loop 结束后，调用这个函数开始 loop。如果 flags == 0，直至 loop 没有活跃的时间或者是调用了 ev_bread 之后停止。
Loop 可以是异常使能的，你可以在 callback 中调用longjmp来终端回调并且跳出 ev_run，或者通过抛出 C++ 异常。这些不会导致 ev_depth 值减少。
EVRUN_NOWAIT会检查并且执行所有未解决的 events，但如果没有就绪的时间，ev_run 会立刻返回。EVRUN_ONCE会检查所有的 events，在至少每一个 event 都执行了一次事件迭代之后才返回。但有时候，使用ev_prepare/ev_check更好。
以下是ev_run的大致工作流程：
loop depth ++
重设ev_break状态
在首次迭代之前，调用所有 pending watchers
LOOP：
如果置了EVFLAG_FORKCHECK，则检查 fork，如果检测到 fork，则排队并调用所有的 fork watchers
排队并且调用所有 ready 的watchers
如果ev_break被调用了，则直接跳转至 FINISH
如果检测到了 fork，则分离并且重建 kernel state
使用所有未解决的变化更新 kernel state
更新ev_now的值
计算要 sleep 或 block 多久
如果指定了的话，sleep
loop iteration ++
阻塞以等待事件
排队所有未处理的I/O事件
更新ev_now的值，执行 time jump 调整
排队所有超时事件
排队所有定期事件
排队所有优先级高于 pending 事件的 idle watchers
排队所有 check watchers
按照上述顺序的逆序，调用 watchers (check watchers -> idle watchers -> 定期事件 -> 计时器超时事件 -> fd事件)。信号和 child watchers 视为 fd watchers。
如果ev_break被调用了，或者使用了EVRUN_ONCE或者EVRUN_NOWAIT，则如果没有活跃的 watchers，则 FINISH，否则 continue
FINISH：
如果是EVBREAK_ONE，则重设 ev_break 状态
loop depth --
return

libev 源码浅析
https://www.cnblogs.com/foxmailed/archive/2013/02/04/2891077.html

libev源码解析——I/O模型
https://cloud.tencent.com/developer/article/1383771
https://blog.csdn.net/breaksoftware/article/details/76737425
https://www.cnblogs.com/leng2052/p/5392638.html
https://cloud.tencent.com/developer/article/1383770
 
libev源码解析——调度策略
https://cloud.tencent.com/developer/article/1383768

libev源码解析——定时器监视器和组织形式
https://cloud.tencent.com/developer/article/1383767

libev源码解析——I/O模型
绑定CPU逻辑核心的利器——taskset

#缓存
##[codis]https://github.com/CodisLabs/codis/blob/release3.2/doc/tutorial_zh.md
