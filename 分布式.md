#微服务

##服务降级、熔断、限流、排队
https://www.jianshu.com/p/33f394c0ee2d

##tars
https://blog.csdn.net/shuishishuideyingzi/article/details/89460973
https://www.cnblogs.com/lidabo/p/9122132.html
https://www.cnblogs.com/qwangxiao/p/11248817.html
https://blog.csdn.net/u014520797/article/details/80877639
https://www.liangzl.com/get-article-detail-18305.html
安装
https://blog.csdn.net/sunshine1314/article/details/81151080
https://blog.csdn.net/qq_40477151/article/details/81166838

源码
https://cloud.tencent.com/developer/article/1381515
https://cloud.tencent.com/developer/article/1381523?from=10680

https://cloud.tencent.com/developer/article/1394046
设计
https://www.jianshu.com/p/cfb778c452cd

##libco
https://www.cnblogs.com/dearplain/p/9820913.html
https://blog.csdn.net/u011579138/article/details/81839840
https://blog.csdn.net/zimengyu2020/article/details/80217499

##brpc

https://github.com/apache/incubator-brpc/blob/master/docs/cn/getting_started.md
https://cloud.tencent.com/developer/article/1383845
https://gitee.com/mirrors/BRPC


##grpc
https://blog.csdn.net/weiwangchao_/article/details/82023191
https://www.cnblogs.com/TianFang/p/4355280.html

##thrift
https://blog.csdn.net/zkp_java/article/details/81879577
https://blog.csdn.net/jek123456/article/details/53395206
https://www.jianshu.com/p/cf91da1e3f8d

##aba
https://blog.csdn.net/qq_42576040/article/details/88240595

##zookeeper
https://www.w3cschool.cn/zookeeper/zookeeper_cli.html
https://www.w3cschool.cn/zookeeper/zookeeper_overview.html
zookeeper快速入门——简介
https://cloud.tencent.com/developer/article/1383764

##eureka
https://blog.csdn.net/rubbertree/article/details/95085507
https://blog.csdn.net/tianyaleixiaowu/article/details/78192922
https://www.cnblogs.com/demodashi/p/8509931.html
https://www.cnblogs.com/feixiangdecainiao/p/10850558.html
https://www.jianshu.com/p/c18db3a2efc6

##zab
https://www.cnblogs.com/crazylqy/p/7132133.html
https://www.cnblogs.com/crazylqy/p/7132369.html
https://www.imooc.com/article/260128

##调用链
https://www.jianshu.com/p/da80ea881424

##灰度 共享内存
https://my.oschina.net/izhangll/blog/884713

##keepalived
https://blog.51cto.com/superpcm/2095395

##微服务设计
https://book.douban.com/subject/26772677/

##大型分布式系统的优化解决方案
https://blog.csdn.net/xiaopy_0508/article/details/78190102


##《亿级流量网站架构核心技术》概要
https://www.cnblogs.com/jstarseven/p/9174604.html


## 可伸缩服务架构
《可伸缩服务架构 框架与中间件》综合（1）
https://blog.csdn.net/u011692924/article/details/81938019
《可伸缩服务架构 框架与中间件》综合（2）
https://blog.csdn.net/u011692924/article/details/81938235
《可伸缩服务架构 框架与中间件》综合（3）
https://blog.csdn.net/u011692924/article/details/82988759
《可伸缩服务架构 框架与中间件》综合（4）
https://blog.csdn.net/u011692924/article/details/82989820

分库分表的架构设计—《可伸缩服务架构》
https://blog.csdn.net/ok449a6x1i6qq0g660fV/article/details/80193375


#消息中间件
##kafka
https://github.com/wurstmeister/kafka-docker

##rabbit mq
https://github.com/alanxz/rabbitmq-c
https://www.cnblogs.com/knowledgesea/p/6535766.html
https://www.jianshu.com/p/6376936845ff
https://pdf.us/2018/06/07/1260.html
https://blog.csdn.net/jinyidong/article/details/80003362
https://pdf.us/2018/06/12/1311.html

https://blog.csdn.net/hellozpc/article/details/81436980#83Topic_Exchange_1429
https://www.cnblogs.com/ysocean/p/9251884.html

RabbitMQ教程
https://blog.csdn.net/hellozpc/article/details/81436980

RabbitMQ镜像队列的故障恢复
http://www.360doc.com/content/15/0312/15/20874412_454584335.shtml

rabbitMq集群之镜像模式
https://blog.csdn.net/wexiaoword/article/details/81352045

消息中间件面试题：消息队列的优缺点，区别
https://blog.csdn.net/Iperishing/article/details/86674084

##消息中间件（一）MQ详解及四大MQ比较
https://blog.csdn.net/wqc19920906/article/details/82193316


#调用链
##[cat]https://github.com/dianping/cat/
##[GRPC java 分布式调用链跟踪实践]https://www.jianshu.com/p/2ec0f8d4ae3d
## 分布式追踪OpenTracing与 Jaeger 实现  
https://github.com/jaegertracing/jaeger-client-cpp
https://blog.csdn.net/m0_37598953/article/details/88760603
https://www.kancloud.cn/idzqj/customer/1691930

##OpenTracing
https://www.jianshu.com/p/d2b11c079af0
https://studygolang.com/articles/13583

##jaeger 使用初探
https://www.cnblogs.com/chopper-poet/p/10743141.html

##Linux下从零开始部署和使用Jaeger
https://www.jianshu.com/p/e224b5871998

##全链路监控Jaeger搭建实战
https://www.jianshu.com/p/ffc597bb4ce8

##基于jaeger微服务调用链实现方案
https://cloud.tencent.com/developer/article/1494063

##ZIPKIN
ZIPKIN的搭建使用过程
https://blog.csdn.net/m15231417197/article/details/81540829

##ZIPKIN
https://blog.csdn.net/qq_27384769/article/details/84965170
概述
zipkin为分布式链路调用监控系统，聚合各业务系统调用延迟数据，达到链路调用监控跟踪。
在复杂的调用链路中假设存在一条调用链路响应缓慢，如何定位其中延迟高的服务呢？
日志： 通过分析调用链路上的每个服务日志得到结果
zipkin：使用zipkin的web UI可以一眼看出延迟高的服务
zipkin
zipkin主要涉及四个组件 collector storage search web UI
Collector接收各service传输的数据
Cassandra作为Storage的一种，也可以是mysql等，默认存储在内存中，配置cassandra可以参考这里
Query负责查询Storage中存储的数据,提供简单的JSON API获取数据，主要提供给web UI使用
Web 提供简单的web界面
使用zipkin涉及几个概念
1. Span:基本工作单元，一次链路调用(可以是RPC，DB等没有特定的限制)创建一个span，通过一个64位ID标识它， 
span通过还有其他的数据，例如描述信息，时间戳，key-value对的(Annotation)tag信息，parent-id等,其中parent-id 
可以表示span调用链路来源，通俗的理解span就是一次请求信息
2. Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识
3. Annotation: 注解,用来记录请求特定事件相关信息(例如时间)，通常包含四个注解信息

cs - Client Start,表示客户端发起请求
sr - Server Receive,表示服务端收到请求
ss - Server Send,表示服务端完成处理，并将结果发送给客户端
cr - Client Received,表示客户端获取到服务端返回信息
4. BinaryAnnotation:提供一些额外信息，一般已key-value对出现

##zipkin c/c++库编译及环境搭建
https://blog.csdn.net/upsuperman/article/details/78049411

##C++ opentracing zipkin 
https://www.cnblogs.com/resibe-3/p/8628561.html

##ZipKin原理学习--ZipKin入门介绍
https://blog.csdn.net/qq924862077/article/details/80285536

##调用追踪存储展示应用——zipkin环境搭建
https://blog.csdn.net/upsuperman/article/details/78048972

##分布式跟踪系统（一）：Zipkin的背景和设计
https://blog.csdn.net/manzhizhen/article/details/52811600

##分布式跟踪系统（二）：Zipkin的Span模型
https://blog.csdn.net/manzhizhen/article/details/53865368?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2

##zipkin trace数据结构说明（四） 
https://shared-code.com/article/105

##Zipkin 简单分析
https://blog.csdn.net/xsj34567/article/details/80939622

##ZIPKIN的搭建使用过程
https://blog.csdn.net/m15231417197/article/details/81540829

##SpringCloud微服务监控——zipkin：微服务链路跟踪
https://blog.csdn.net/fyk844645164/article/details/98746821

#网络库
##libev
libev学习（一） https://www.cnblogs.com/qigaohua/p/5883400.html
   bool ev_run (struct ev_loop *loop, int flags);
初始化 loop 结束后，调用这个函数开始 loop。如果 flags == 0，直至 loop 没有活跃的时间或者是调用了 ev_bread 之后停止。
Loop 可以是异常使能的，你可以在 callback 中调用longjmp来终端回调并且跳出 ev_run，或者通过抛出 C++ 异常。这些不会导致 ev_depth 值减少。
EVRUN_NOWAIT会检查并且执行所有未解决的 events，但如果没有就绪的时间，ev_run 会立刻返回。EVRUN_ONCE会检查所有的 events，在至少每一个 event 都执行了一次事件迭代之后才返回。但有时候，使用ev_prepare/ev_check更好。
以下是ev_run的大致工作流程：
loop depth ++
重设ev_break状态
在首次迭代之前，调用所有 pending watchers
LOOP：
如果置了EVFLAG_FORKCHECK，则检查 fork，如果检测到 fork，则排队并调用所有的 fork watchers
排队并且调用所有 ready 的watchers
如果ev_break被调用了，则直接跳转至 FINISH
如果检测到了 fork，则分离并且重建 kernel state
使用所有未解决的变化更新 kernel state
更新ev_now的值
计算要 sleep 或 block 多久
如果指定了的话，sleep
loop iteration ++
阻塞以等待事件
排队所有未处理的I/O事件
更新ev_now的值，执行 time jump 调整
排队所有超时事件
排队所有定期事件
排队所有优先级高于 pending 事件的 idle watchers
排队所有 check watchers
按照上述顺序的逆序，调用 watchers (check watchers -> idle watchers -> 定期事件 -> 计时器超时事件 -> fd事件)。信号和 child watchers 视为 fd watchers。
如果ev_break被调用了，或者使用了EVRUN_ONCE或者EVRUN_NOWAIT，则如果没有活跃的 watchers，则 FINISH，否则 continue
FINISH：
如果是EVBREAK_ONE，则重设 ev_break 状态
loop depth --
return

libev 源码浅析
https://www.cnblogs.com/foxmailed/archive/2013/02/04/2891077.html

libev源码解析——I/O模型
https://cloud.tencent.com/developer/article/1383771
https://blog.csdn.net/breaksoftware/article/details/76737425
https://www.cnblogs.com/leng2052/p/5392638.html
https://cloud.tencent.com/developer/article/1383770
 
libev源码解析——调度策略
https://cloud.tencent.com/developer/article/1383768

libev源码解析——定时器监视器和组织形式
https://cloud.tencent.com/developer/article/1383767

libev源码解析——I/O模型
绑定CPU逻辑核心的利器——taskset

#缓存
##[codis]https://github.com/CodisLabs/codis/blob/release3.2/doc/tutorial_zh.md

#HTTP
看完这篇HTTP，跟面试官扯皮就没问题了
https://blog.csdn.net/qq_36894974/article/details/103930478?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-17.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-17.nonecase

