
##多线程
https://www.cnblogs.com/ljygoodgoodstudydaydayup/p/5950400.html
https://blog.csdn.net/chenjiayi_yun/article/details/43938623
https://blog.csdn.net/chenjiayi_yun/article/details/40427141
https://blog.csdn.net/qq_43401808/article/details/86540962
https://blog.csdn.net/chenjiayi_yun/article/details/19023135

https://www.e-learn.cn/content/qita/1141137
https://www.cnblogs.com/fudong071234/p/6759567.html
https://www.jianshu.com/p/6f5c38da6430
https://www.cnblogs.com/liang1101/p/7285955.html

https://blog.csdn.net/longbei9029/article/details/60956892

##多线程模型并发处理
###c++多线程编程：常见面试题
https://www.cnblogs.com/ljygoodgoodstudydaydayup/p/5950400.html
####condition_variable mutex
题目：子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环50次，试写出代码

子线程与主线程必有一个满足条件(flag == num),不满足条件的那个线程不可能获取unique_lock(会在wait中释放)，只有满足条件的线程才能获取锁，执行程序

mutex m;//保护条件的互斥访问
condition_variable cond;//条件变量
int flag = 10;//条件
void fun(int num) {
    for (int i = 0; i<50; i++) {
        unique_lock<mutex> lk(m);//A unique lock is an object that manages a mutex object with unique ownership in both states: locked and unlocked.  
        while (flag != num)
            cond.wait(lk);//在调用wait时会执行lk.unlock()  
        for (int j = 0; j<num; j++)
            cout << j << " ";
        cout << endl;
        flag = (num == 10) ? 100 : 10;
        cond.notify_one();//被阻塞的线程唤醒后lk.lock()恢复在调用wait前的状态  
    }
}
int main() {
    thread child(fun, 10);
    fun(100);
    child.join();
    system("pause");
    return 0;
}
题目：编写一个程序，开启3个线程，这3个线程的ID分别为A、B、C，每个线程将自己的ID在屏幕上打印10遍，要求输出结果必须按ABC的顺序显示；如：ABCABC….依次递推。

mutex m;
condition_variable cond;
int loop = 10;
int flag = 0;

void func(int id)
{
    for (int i = 0; i < loop; ++i)
    {
        unique_lock<mutex> lk(m);
        while (flag != id)
            cond.wait(lk);
        cout << static_cast<char>('A' + id) << " ";
        flag = (flag + 1) % 3;
        cond.notify_all();
    }
}

void main()
{
    thread A(func, 0);
    thread B(func, 1);
    func(2);
    cout << endl;
    A.join();
    B.join();
    system("pause");
}

题目(google笔试题)：有四个线程1、2、3、4。线程1的功能就是输出1，线程2的功能就是输出2，以此类推.........现在有四个文件ABCD。初始都为空。现要让四个文件呈如下格式：
A：1 2 3 4 1 2....
B：2 3 4 1 2 3....
C：3 4 1 2 3 4....

D：4 1 2 3 4 1....

mutex m;
condition_variable cond;
int loop = 10;
int flag;

void func(int num)
{
    for (int i = 0; i < loop; ++i)
    {
        unique_lock<mutex> lk(m);
        while (num != flag)
            cond.wait(lk);
        cout << num + 1 << " ";
        flag = (flag + 1) % 4;
        cond.notify_all();
    }
}

void main(int argc,char *argv[])
{
    flag = atoi(argv[1]);
    thread one(func, 1);
    thread two(func, 2);
    thread three(func, 3);
    func(0);
    one.join();
    two.join();
    three.join();
    cout << endl;
    system("pause");
}
读者写者问题

这也是一个非常经典的多线程题目，题目大意如下：有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者读时写者也不能写。

复制代码
class rwlock {
private:
    mutex _lock;
    condition_variable _wcon, _rcon;
    unsigned _writer, _reader;
    int _active;
public:
    void read_lock() {
        unique_lock<mutex> lock(_lock);
        ++_reader;
        while (_active < 0 || _writer > 0)
            _rcon.wait(lock);
        --_reader;
        ++_active;
    }
    void write_lock() {
        unique_lock<mutex> lock(_lock);
        ++_writer;
        while (_active != 0)
            _wcon.wait(lock);
        --_writer;
        _active = -1;
    }
    void unlock() {
        unique_lock<mutex> lock(_lock);
        if (_active > 0) {
            --_active;
            if (_active == 0) _wcon.notify_one();
        }
        else {
            _active = 0;
            if (_writer > 0) _wcon.notify_one();
            else if (_reader > 0) _rcon.notify_all();
        }
    }
    rwlock() :_writer(0), _reader(0), _active(0) {
    }
};

void t1(rwlock* rwl) {
    while (1) {
        cout << "I want to write." << endl;
        rwl->write_lock();
        cout << "writing..." << endl;
        this_thread::sleep_for(chrono::seconds(5));
        rwl->unlock();
        this_thread::sleep_for(chrono::seconds(5));
    }
}

void t2(rwlock* rwl) {
    while (1) {
        cout << "t2-I want to read." << endl;
        rwl->read_lock();
        cout << "t2-reading..." << endl;
        this_thread::sleep_for(chrono::seconds(1));
        rwl->unlock();
    }
}

void t3(rwlock* rwl) {
    while (1) {
        cout << "t3-I want to read." << endl;
        rwl->read_lock();
        cout << "t3-reading..." << endl;
        this_thread::sleep_for(chrono::seconds(1));
        rwl->unlock();
    }
}

int main()
{
    rwlock* rwl = new rwlock();
    thread th1(t1, rwl);
    thread th2(t2, rwl);
    thread th3(t3, rwl);
    th1.join();
    th2.join();
    th3.join();
    system("pause");
    return 0;
}
 

####线程安全的queue

STL中的queue是非线程安全的，一个组合操作：front(); pop()先读取队首元素然后删除队首元素，若是有多个线程执行这个组合操作的话，可能会发生执行序列交替执行，导致一些意想不到的行为。因此需要重新设计线程安全的queue的接口。

复制代码
template<typename T>
class threadsafe_queue
{
private:
    mutable std::mutex mut;
    std::queue<T> data_queue;
    std::condition_variable data_cond;
public:
    threadsafe_queue() {}
    threadsafe_queue(threadsafe_queue const& other)
    {
        std::lock_guard<std::mutex> lk(other.mut);
        data_queue = other.data_queue;
    }
    void push(T new_value)//入队操作  
    {
        std::lock_guard<std::mutex> lk(mut);
        data_queue.push(new_value);
        data_cond.notify_one();
    }
    void wait_and_pop(T& value)//直到有元素可以删除为止  
    {
        std::unique_lock<std::mutex> lk(mut);
        data_cond.wait(lk, [this] {return !data_queue.empty(); });
        value = data_queue.front();
        data_queue.pop();
    }
    std::shared_ptr<T> wait_and_pop()
    {
        std::unique_lock<std::mutex> lk(mut);
        data_cond.wait(lk, [this] {return !data_queue.empty(); });
        std::shared_ptr<T> res(std::make_shared<T>(data_queue.front()));
        data_queue.pop();
        return res;
    }
    bool try_pop(T& value)//不管有没有队首元素直接返回  
    {
        std::lock_guard<std::mutex> lk(mut);
        if (data_queue.empty())
            return false;
        value = data_queue.front();
        data_queue.pop();
        return true;
    }
    std::shared_ptr<T> try_pop()
    {
        std::lock_guard<std::mutex> lk(mut);
        if (data_queue.empty())
            return std::shared_ptr<T>();
        std::shared_ptr<T> res(std::make_shared<T>(data_queue.front()));
        data_queue.pop();
        return res;
    }
    bool empty() const
    {
        std::lock_guard<std::mutex> lk(mut);
        return data_queue.empty();
    }
};
####atomic
题目：编写程序完成如下功能：

1）有一int型全局变量g_Flag初始值为0

2） 在主线称中起动线程1，打印“this is thread1”，并将g_Flag设置为1

3） 在主线称中启动线程2，打印“this is thread2”，并将g_Flag设置为2

4） 线程序1需要在线程2退出后才能退出

5） 主线程在检测到g_Flag从1变为2，或者从2变为1的时候退出

atomic<int> flag(0);

void worker1(future<int> fut) 
{//线程1  
    printf("this is thread1\n");
    flag = 1;
    fut.get();//线程1阻塞至线程2设置共享状态  get等待异步操作结束并返回结果
    printf("thread1 exit\n");
}

void worker2(promise<int> prom) 
{//线程2  
    printf("this is thread2\n");//C++11的线程输出cout没有boost的好，还是会出现乱序，所以采用printf，有点不爽  
    flag = 2;
    prom.set_value(10);//线程2设置了共享状态后，线程1才会被唤醒  
    printf("thread2 exit\n");
}

//利用promise future来控制线程退出的次序
int main()
{
    promise<int> prom;
    future<int> fut = prom.get_future();
    thread one(worker1, move(fut));//注意future和promise不允许拷贝，但是具备move语义  
    thread two(worker2, move(prom));
    while (flag.load() == 0);
　　///将本线程从调用线程中分离出来，允许本线程独立执行
    one.detach();
    two.detach();
    //exit(1);//主线程到这里退出  
    printf("main thread exit\n");
    system("pause");
    return 0;
}

###C/C++并发编程（1）—— 并发/并行、多线程内存模型
https://www.jianshu.com/p/298296e9a887

https://blog.csdn.net/qq_40273354/article/details/78494504

##线程
http://www.cplusplus.com/reference/condition_variable/condition_variable/
http://www.cplusplus.com/reference/condition_variable/condition_variable/notify_all/
http://www.cplusplus.com/reference/condition_variable/condition_variable_any/
https://www.cnblogs.com/huty/p/8516997.html

##线程控制
https://blog.csdn.net/chenjiayi_yun/article/details/18059665
###1、Linux 线程概念
     进程与线程之间是有区别的，不过Linux内核只提供了轻量进程的支持，而其所谓的线程本质上在内核里仍然是进程。

     进程是资源分配的单位，同一进程中的多个线程共享该进程的资源。Linux中的线程只是在被创建时clone了父进程的资源，因此clone出来的进程表现为线程，只是它有共享父进程资源的特性。

   程序与线程库相链接即可支持Linux平台上的多线程，在程序中需包含头文件pthread. h，在编译链接时使用命令： 
gcc -D -REENTRANT -lpthread xxx. c

其中-REENTRANT宏使得相关库函数(如stdio.h、errno.h中函数) 是可重入的、线程安全的(thread-safe)，-lpthread则意味着链接库目录下的libpthread.a或libpthread.so文件。

流行的线程模型有LinuxThreads 和 NPTL。使用线程库需要2.0以上版本的Linux内核,及相应版本的C库(libc 或glibc )。

参考：http://www.ibm.com/developerworks/cn/linux/l-threading.html

###2、线程控制 
（1）线程创建 
进程被创建时，系统会为其创建一个主线程，而要在进程中创建新的线程，则可以调用pthread_create： 
pthread_create(pthread_t *thread, const pthread_attr_t *attr, void * (start_routine)(void*), void *arg);

start_routine为新线程的入口函数，arg为传递给start_routine的参数。 

每个线程都有自己的线程ID，以便在进程内区分。线程ID在pthread_create调用时回返给创建线程的调用者；一个线程也可以在创建后使用pthread_self()调用获取自己的线程ID： 

pthread_self (void) ;

（2）线程退出 
线程的退出方式： 
1）执行完成后隐式退出
2）由线程本身显示调用pthread_exit 函数退出
pthread_exit (void * retval) ;

3）被其他线程用pthread_cance函数终止
pthread_cance (pthread_t thread) ;

在某线程中调用此函数，可以终止由参数thread 指定的线程。 

如果一个线程要等待另一个线程的终止，可以使用pthread_join函数，该函数的作用是调用pthread_join的线程将被挂起直到线程ID为参数thread的线程终止： 

pthread_join (pthread_t thread, void** threadreturn);

###3、线程通信 
####（1）线程互斥 
互斥意味着“排它”，即两个线程不能同时进入被互斥保护的代码。Linux下可以通过pthread_mutex_t 定义互斥体机制完成多线程的互斥操作，该机制的作用是对某个需要互斥的部分，在进入时先得到互斥体，如果没有得到互斥体，表明互斥部分被其它线程拥有，此时欲获取互斥体的线程阻塞，直到拥有该互斥体的线程完成互斥部分的操作为止。 

下面的代码实现了对共享全局变量x1 用互斥体mutex 进行保护的目的： 
int x1; // 进程中的全局变量 
pthread_mutex_t mutex; 
pthread_mutex_init(&mutex, NULL); //按缺省的属性初始化互斥体变量mutex 
pthread_mutex_lock(&mutex); // 给互斥体变量加锁 
… //对变量x1 的操作 
phtread_mutex_unlock(&mutex); // 给互斥体变量解除锁

####（2）线程同步 
同步就是线程等待某个事件的发生。只有当等待的事件发生线程才继续执行，否则线程挂起并放弃处理器。当多个线程协作时，相互作用的任务必须在一定的条件下同步。 
#####1）条件变量
Linux下的C语言编程有多种线程同步机制，最典型的是条件变量(condition variable)。
pthread_cond_init用来创建一个条件变量，其函数原型为： 
pthread_cond_init (pthread_cond_t *cond, const pthread_condattr_t *attr);

pthread_cond_wait和pthread_cond_timedwait用来等待条件变量被设置，值得注意的是这两个等待调用需要一个已经上锁的互斥体mutex，这是为了防止在真正进入等待状态之前别的线程有可能设置该条件变量而产生竞争。

pthread_cond_wait的函数原型为： 
pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex);


pthread_cond_broadcast用于设置条件变量，即使得事件发生，这样等待该事件的线程将不再阻塞： 
pthread_cond_broadcast (pthread_cond_t *cond) ;
pthread_cond_signal则用于解除某一个等待线程的阻塞状态： 
pthread_cond_signal (pthread_cond_t *cond) ;

pthread_cond_destroy(pthread_cond_t *cond)  则用于释放一个条件变量的资源。 
pthread_cond_destroy(pthread_cond_t *cond) ；

pthread_cond_timedwait 计时等待方式

int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);

如果在给定时刻前条件没有满足，则返回ETIMEOUT，结束等待，其中abstime以与time()系统调用相同意义的绝对时间形式出现，0表示格林尼治时间1970年1月1日0时0分0秒。

pthread_cond_timedwait 和pthread_cond_wait，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。
激发条件有两种形式，pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。


条件变量实例1：
以名的生产者/消费者问题为例来阐述Linux线程的控制和通信。一组生产者线程与一组消费者线程通过缓冲区发生联系。生产者线程将生产的产品送入缓冲区，消费者线程则从中取出产品。缓冲区有N 个，是一个环形的缓冲池。 

// 缓冲区相关数据结构
struct prodcons
{
    int buffer[BUFFER_SIZE]; /* 实际数据存放的数组*/
    pthread_mutex_t lock; /* 互斥体lock 用于对缓冲区的互斥操作 */
    int readpos, writepos; /* 读写指针*/
    pthread_cond_t notempty; /* 缓冲区非空的条件变量（写者通知读者的信号） */
    pthread_cond_t notfull; /* 缓冲区未满的条件变量 （读者通知写者的信号）*/
};
 
/* 初始化缓冲区结构 */
void init(struct prodcons *b)
{
    pthread_mutex_init(&b->lock, NULL);
    pthread_cond_init(&b->notempty, NULL);
    pthread_cond_init(&b->notfull, NULL);
    b->readpos = 0;
    b->writepos = 0;
}
/* 将产品放入缓冲区,这里是存入一个整数*/
void put(struct prodcons *b, int data)
{
    pthread_mutex_lock(&b->lock);
    /* 等待缓冲区未满*/
    if ((b->writepos + 1) % BUFFER_SIZE == b->readpos)
    {
        pthread_cond_wait(&b->notfull, &b->lock);//数据已满，等待读者发送信号
    }
    /* 写数据,并移动指针 */
    b->buffer[b->writepos] = data;
    b->writepos++;
    if (b->writepos >= BUFFER_SIZE)
        b->writepos = 0;
    /* 设置缓冲区非空的条件变量*/
    if (b->writepos == (b->readpos + 1) % BUFFER_SIZE)//判断通知条件
    pthread_cond_signal(&b->notempty);//放了一个数据，就通知一次读者
    pthread_mutex_unlock(&b->lock);
} 
/* 从缓冲区中取出整数*/
int get(struct prodcons *b)
{
    int data;
    pthread_mutex_lock(&b->lock);
    /* 等待缓冲区非空*/
    if (b->writepos == b->readpos)
    {
        pthread_cond_wait(&b->notempty, &b->lock);//读者等待写者发送信号
    }
    /* 读数据,移动读指针*/
    data = b->buffer[b->readpos];
    b->readpos++;
    if (b->readpos >= BUFFER_SIZE)
        b->readpos = 0;
    /* 设置缓冲区未满的条件变量*/
    if ((b->writepos + 2) % BUFFER_SIZE == b->readpos)//判断通知条件
    pthread_cond_signal(&b->notfull);//读者发送信号给写者
    pthread_mutex_unlock(&b->lock);
    return data;
}
 
/* 测试:生产者线程将1 到10000 的整数送入缓冲区,消费者线
   程从缓冲区中获取整数,两者都打印信息*/
int OVER ( - 1)
struct prodcons buffer;
void *producer(void *data)
{
    int n;
    for (n = 0; n < 10000; n++)
    {
        printf("%d --->\n", n);
        put(&buffer, n);
    }
    put(&buffer, OVER);
    return NULL;
}
 
void *consumer(void *data)
{
    int d;
    while (1)
    {
        d = get(&buffer);
        if (d == OVER)
            break;
        printf("--->%d \n", d);
    }
    return NULL;
}
 
int main(void)
{
    pthread_t th_a, th_b;
    void *retval;
    init(&buffer);
    /* 创建生产者和消费者线程*/
    pthread_create(&th_a, NULL, producer, 0);
    pthread_create(&th_b, NULL, consumer, 0);
    /* 等待两个线程结束*/
    pthread_join(th_a, &retval);
    pthread_join(th_b, &retval);
    return 0;
}

条件变量实例2：

static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
 
struct node
{
    intn_number;
    structnode *n_next;
} *head = NULL; /*[thread_func]*/
 
 
/*释放节点内存 */
static void cleanup_handler(void*arg)
{
    printf("Cleanup handler of second thread.\n");
    free(arg);
    pthread_mutex_unlock(&mtx);
}
 
static void* thread_func(void*arg)
{
    structnode *p = NULL;
    pthread_cleanup_push(cleanup_handler, p);//pthread_cond_wait是取消点，所以需要在被取消时解锁
    while(1)
    {
        pthread_mutex_lock(&mtx);
        //这个mutex_lock主要是用来保护wait等待临界时期的情况，
        //当在wait为放入队列时，这时，已经存在Head条件等待激活
        //的条件，此时可能会漏掉这种处理
        //这个while要特别说明一下，单个pthread_cond_wait功能很完善，
        //为何这里要有一个while (head == NULL)呢？因为pthread_cond_wait
        //里的线程可能会被意外唤醒，如果这个时候head == NULL，则
        //则不是我们想要的情况。这个时候，
        //应该让线程继续进入pthread_cond_wait
        //（本例逻辑上使用if while(head == NULL)也可以达到目的，使用while(head == NULL)是为了编码安全的习惯）
        while(head == NULL)
        {
            pthread_cond_wait(&cond, &mtx);
            // pthread_cond_wait会先解除之前的pthread_mutex_lock锁定的mtx，
            //然后阻塞在等待队列里休眠，直到再次被唤醒
            //（大多数情况下是等待的条件成立而被唤醒，唤醒后，
            //该进程会先锁定先pthread_mutex_lock(&mtx);，
            // 再读取资源 用这个流程是比较清楚的
            /*block-->unlock-->wait() return-->lock*/
        }
	      p = head;
        head = head->n_next;
        printf("Got %d from front of queue\n", p->n_number);
        free(p);
        pthread_mutex_unlock(&mtx);//临界区数据操作完毕，释放互斥锁
    }
    pthread_cleanup_pop(0);
    return0;
}
 
int main(void)
{
    pthread_t tid;
    inti;
    structnode *p;
    pthread_create(&tid, NULL, thread_func, NULL);
    //子线程会一直等待资源，类似生产者和消费者，
    //但是这里的消费者可以是多个消费者，
    //而不仅仅支持普通的单个消费者，这个模型虽然简单，但是很强大
    for(i = 0; i < 10; i++)
    {
        p = (struct node *)malloc(sizeof(struct node));//分配新节点
        p->n_number = i;
        pthread_mutex_lock(&mtx);//需要操作head这个临界资源，先加锁(需要修改共享资源的才在pthread_cond_signal前后加锁，并把资源操作放置在临界区内)
        p->n_next = head;//放到链表头部
        head = p;
        pthread_cond_signal(&cond);//有数据就通知读者
        pthread_mutex_unlock(&mtx);//解锁
        sleep(1);
    }
    printf("thread 1 wanna end the cancel thread 2.\n");
    pthread_cancel(tid);
    //关于pthread_cancel，有一点额外的说明，它是从外部终止子线程，
    //子线程会在最近的取消点，退出线程，而在我们的代码里，最近的
    //取消点肯定就是pthread_cond_wait()了。
    pthread_join(tid, NULL);
    printf("All done -- exiting\n");
    return0;
}

#####2）信号量
在头文件semaphore.h 中定义的信号量则完成了互斥体和条件变量的封装，按照多线程程序设计中访问控制机制，控制对资源的同步访问，提供程序设计人员更方便的调用接口。 

sem_init(sem_t *sem, int pshared, unsigned int val);
这个函数初始化一个信号量sem 的值为val，参数pshared 是共享属性控制，表明是否在进程间共享。 

sem_wait(sem_t *sem);

调用该函数时，若sem为无状态，调用线程阻塞，等待信号量sem值增加(post )成为有信号状态；若sem为有状态，调用线程顺序执行，但信号量的值减一。

sem_post(sem_t *sem); 

调用该函数，信号量sem的值增加，可以从无信号状态变为有信号状态。
 

###4、WIN32、Linux线程函数比较

对于win32和linux的线程控制和线程通信函数，本质内容一致。接口如下：

事项	WIN32	Linux	 
线程创建	CreateThread	pthread_create	 
线程终止	执行完成后退出；线程自身调用ExitThread函数即终止自己；被其他线程调用函数TerminateThread函数	执行完成后退出；由线程本身调用pthread_exit 退出；被其他线程调用函数pthread_cance终止	 
获取线程ID	GetCurrentThreadId	pthread_self	 
创建互斥	CreateMutex	pthread_mutex_init	 
获取互斥	WaitForSingleObject、WaitForMultipleObjects	pthread_mutex_lock	 
释放互斥	ReleaseMutex	phtread_mutex_unlock	 
创建信号量	CreateSemaphore	sem_init	 
等待信号量	WaitForSingleObject	sem_wait	 
释放信号量	ReleaseSemaphore	sem_post	

##线程池
https://github.com/lzpong/threadpool/blob/master/threadpool.h



##读写锁
https://www.cnblogs.com/i80386/p/4478021.html
https://www.cnblogs.com/i80386/p/4478021.html
https://www.cnblogs.com/defen/p/4410232.html
https://blog.csdn.net/yand789/article/details/27324295

##atomic
http://www.cplusplus.com/reference/atomic/atomic/exchange/
https://blog.csdn.net/FreeeLinux/article/details/53695111
https://www.cnblogs.com/dengzz/p/5686866.html

##原子
https://blog.csdn.net/chenjiayi_yun/article/details/16333779

##thread_local
###C++11多线程-线程局部存储(thread_local)
https://www.jianshu.com/p/8df45004bbcb

线程局部存储在其它语言中都是以库的形式提供的(库函数或类)。但在C++11中以关键字的形式，做为一种存储类型出现，由此可见C++11对线程局部存储的重视。C++11中有如下几种存储类型:

序号	类型	备注
1	auto	该关键字用于两种情况：
1. 声明变量时： 根据初始化表达式自动推断变量类型。
2. 声明函数作为函数返回值的占位符。
2	static	static变量只初始化一次，除此之外它还有可见性的属性：
1. static修饰函数内的“局部”变量时，表明它不需要在进入或离开函数时创建或销毁。且仅在函数内可见。
2. static修饰全局变量时，表明该变量仅在当前(声明它的)文件内可见。
3. static修饰类的成员变量时，则该变量被该类的所有实例共享。
3	register	寄存器变量。该变量存储在CPU寄存器中，而不是RAM(栈或堆)中。该变量的最大尺寸等于寄存器的大小。由于是存储于寄存器中，因此不能对该变量进行取地址操作。
4	extern	引用一个全局变量。当在一个文件中定义了一个全局变量时，就可以在其它文件中使用extern来声明并引用该变量。
5	mutable	仅适用于类成员变量。以mutable修饰的成员变量可以在const成员函数中修改。参见上一章chan.simple.h中对mutex的使用。
6	thread_local	线程周期
thread_local修饰的变量具有如下特性:

变量在线程创建时生成(不同编译器实现略有差异，但在线程内变量第一次使用前必然已构造完毕)。
线程结束时被销毁(析构，利用析构特性，thread_local变量可以感知线程销毁事件)。
每个线程都拥有其自己的变量副本。
thread_local可以和static或extern联合使用，这将会影响变量的链接属性。
下面代码演示了thread_local变量在线程中的生命周期

// thread_local.cpp

class A {
public:
  A() {
    std::cout << std::this_thread::get_id()
              << " " << __FUNCTION__
              << "(" << (void *)this << ")"
              << std::endl;
  }

  ~A() {
    std::cout << std::this_thread::get_id()
              << " " << __FUNCTION__
              << "(" << (void *)this << ")"
              << std::endl;
  }

  // 线程中，第一次使用前初始化
  void doSth() {
  }
};

thread_local A a;

int main() {
  a.doSth();
  std::thread t([]() {
    std::cout << "Thread: "
              << std::this_thread::get_id()
              << " entered" << std::endl;
    a.doSth();
  });

  t.join();

  return 0;
}
运行该程序

$> g++ -std=c++11 -o debug/tls.out ./thread_local.cpp
$> ./debug/tls.out
01 A(0xc00720)
Thread: 02 entered
02 A(0xc02ee0)
02 ~A(0xc02ee0)
01 ~A(0xc00720)
$>
变量a在main线程和t线程中分别保留了一份副本，以下时序图表明了两份副本的生命周期。


https://blog.csdn.net/y396397735/article/details/81271339
https://blog.csdn.net/woshi_caibi/article/details/71124390

##yield
https://blog.csdn.net/ldw614/article/details/79924587
https://blog.csdn.net/nirendao/article/details/51628693

##协程
https://www.cnblogs.com/sniperHW/archive/2012/08/05/2624334.html
https://www.cnblogs.com/heluan/p/9689751.html
https://www.jianshu.com/p/837bb161793a

##context
寄存器
https://www.jianshu.com/p/57128e477efb
make_fcountext、jump_fcontext
https://segmentfault.com/a/1190000019154852

协程分析之context上下文切换
https://blog.csdn.net/waruqi/article/details/53201416
https://www.liangzl.com/get-article-detail-578.html
https://blog.csdn.net/libaineu2004/article/details/80554870
https://blog.csdn.net/zdyueguanyun/article/details/60782260
https://gitee.com/DreamThat/libgo
https://www.jianshu.com/p/43216b429583

##阻塞非阻塞 异步同步
http://www.sohu.com/a/231730171_231667

###Unix网络编程中的五种IO模型

Blocking IO - 阻塞IO
NoneBlocking IO - 非阻塞IO
IO multiplexing - IO多路复用
signal driven IO - 信号驱动IO
asynchronous IO - 异步IO

由于signal driven IO在实际使用中并不常用，所以这里只讨论剩下的四种IO模型。

在讨论之前先说明一下IO发生时涉及到的对象和步骤，对于一个network IO，它会涉及到两个系统对象：

application 调用这个IO的进程
kernel 系统内核
那他们经历的两个交互过程是：

阶段1 wait for data 等待数据准备
阶段2 copy data from kernel to user 将数据从内核拷贝到用户进程中
之所以会有同步、异步、阻塞和非阻塞这几种说法就是根据程序在这两个阶段的处理方式不同而产生的。了解了这些背景之后，我们就分别针对四种IO模型进行讲解

###Blocking IO - 阻塞IO

在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概如下图：

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network IO来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。

所以，blocking IO的特点就是在IO执行的两个阶段都被block了。

###NoneBlockingIO - 非阻塞IO

linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：


从图中可以看出，当用户进程发出recvfrom这个系统调用后，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个结果（no datagram ready）。从用户进程角度讲 ，它发起一个操作后，并没有等待，而是马上就得到了一个结果。用户进程得知数据还没有准备好后，它可以每隔一段时间再次发送recvfrom操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。

所以，用户进程其实是需要不断的主动询问kernel数据好了没有。

###IO multiplexing - IO多路复用
I/O多路复用(multiplexing)是网络编程中最常用的模型，像我们最常用的select、epoll都属于这种模型。以select为例：

看起来它与blocking I/O很相似，两个阶段都阻塞。但它与blocking I/O的一个重要区别就是它可以等待多个数据报就绪（datagram ready），即可以处理多个连接。这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。

在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。

当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。

###asynchronous IO - 异步IO

异步I/O在网络编程中几乎用不到，在File I/O中可能会用到：

这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。

https://blog.csdn.net/zh13544539220/article/details/44856363

##高性能网络编程7--tcp连接的内存使用
https://cloud.tencent.com/developer/article/1345061

##大并发下TCP内存消耗优化小记（86万并发业务正常服务） 
https://www.cnblogs.com/x_wukong/p/7998903.html

##tcp内存占用/socket内存占用 
https://www.cnblogs.com/shengulong/p/11623621.html

##Linux 中每个 TCP 连接最少占用多少内存？
https://zhuanlan.zhihu.com/p/25241630
https://www.ctolib.com/topics-110215.html

##HTTP性能极限优化
https://blog.csdn.net/russell_tao/article/details/103952639#comments

##详解HTTP2四大核心特性
https://developer.51cto.com/art/201910/604255.htm

##libgo github
https://github.com/yyzybb537/libgo/blob/master/tutorial/sample14_defer.cpp
