
#网络库
##libev
libev学习（一） https://www.cnblogs.com/qigaohua/p/5883400.html
   bool ev_run (struct ev_loop *loop, int flags);
初始化 loop 结束后，调用这个函数开始 loop。如果 flags == 0，直至 loop 没有活跃的时间或者是调用了 ev_bread 之后停止。
Loop 可以是异常使能的，你可以在 callback 中调用longjmp来终端回调并且跳出 ev_run，或者通过抛出 C++ 异常。这些不会导致 ev_depth 值减少。
EVRUN_NOWAIT会检查并且执行所有未解决的 events，但如果没有就绪的时间，ev_run 会立刻返回。EVRUN_ONCE会检查所有的 events，在至少每一个 event 都执行了一次事件迭代之后才返回。但有时候，使用ev_prepare/ev_check更好。
以下是ev_run的大致工作流程：
loop depth ++
重设ev_break状态
在首次迭代之前，调用所有 pending watchers
LOOP：
如果置了EVFLAG_FORKCHECK，则检查 fork，如果检测到 fork，则排队并调用所有的 fork watchers
排队并且调用所有 ready 的watchers
如果ev_break被调用了，则直接跳转至 FINISH
如果检测到了 fork，则分离并且重建 kernel state
使用所有未解决的变化更新 kernel state
更新ev_now的值
计算要 sleep 或 block 多久
如果指定了的话，sleep
loop iteration ++
阻塞以等待事件
排队所有未处理的I/O事件
更新ev_now的值，执行 time jump 调整
排队所有超时事件
排队所有定期事件
排队所有优先级高于 pending 事件的 idle watchers
排队所有 check watchers
按照上述顺序的逆序，调用 watchers (check watchers -> idle watchers -> 定期事件 -> 计时器超时事件 -> fd事件)。信号和 child watchers 视为 fd watchers。
如果ev_break被调用了，或者使用了EVRUN_ONCE或者EVRUN_NOWAIT，则如果没有活跃的 watchers，则 FINISH，否则 continue
FINISH：
如果是EVBREAK_ONE，则重设 ev_break 状态
loop depth --
return

libev 源码浅析
https://www.cnblogs.com/foxmailed/archive/2013/02/04/2891077.html

libev源码解析——I/O模型
https://cloud.tencent.com/developer/article/1383771
https://blog.csdn.net/breaksoftware/article/details/76737425
https://www.cnblogs.com/leng2052/p/5392638.html
https://cloud.tencent.com/developer/article/1383770
 
libev源码解析——调度策略
https://cloud.tencent.com/developer/article/1383768

libev源码解析——定时器监视器和组织形式
https://cloud.tencent.com/developer/article/1383767

libev源码解析——I/O模型
绑定CPU逻辑核心的利器——taskset


#HTTP
看完这篇HTTP，跟面试官扯皮就没问题了
https://blog.csdn.net/qq_36894974/article/details/103930478?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-17.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-17.nonecase

##http响应chunked格式分析 
https://www.cnblogs.com/hnhycnlc888/p/9488832.html
https://www.cnblogs.com/zhaozhan/archive/2010/08/24/1807639.html


##epoll模型怎么判断客户端断连
https://jingyan.baidu.com/article/67508eb468ff5b9ccb1ce476.html

#网络协议的知识

##《趣谈网络协议》 学习笔记
https://www.cnblogs.com/AlmostWasteTime/p/11393176.html

1、一次请求流程：
　　应用层：DNS、HTTP、HTTPS所在的层。经过应用层的封装，浏览器会将包交给下一层去完成，通过 socket 编程来实现。（HTTP 头：正文格式，正文长度，URL，POST 等）
　　先用 www.baidu.com 类似的域名发起请求，DNS/HTTPDNS 对域名进行解析，得到具体的IP地址。现在一般使用 HTTPS 协议做加密传输数据。
　　传输层。传输层有 UDP 协议和 TCP协议。（TCP头：有2个端口，一个浏览器端口，一个服务器监听端口）
　　网络层：传输层封装完毕后，浏览器会将包交给操作系统的网络层，网络层的协议是 IP协议。（IP 头：里有源 IP 地址，以及目标 IP 地址）
　　知道目标 IP 地址，就得判断 IP 是局域网还是因特网。如果是局域网，通过 ARP 协议，就会获取到局域网内目标服务器的 MAC 地址。网关往往是一个路由器，多个 IP 是一个路由表。（ARP 协议最终也会缓存为一个 ARP 映射表）

　　上述都是从发送请求的机器上获得的 TCP、IP 等数据。MAC 地址是网关通过 ARP 协议获取。
　　链路层：IP 地址发送给网关，是靠 ARP 协议。（网关的 MAC 和 客户端电脑的 MAC）
　　ARP 协议：操作系统会询问包是要送到哪台服务器上的，某服务器的 MAC 地址里的IP，是目标 IP 地址，该服务器就会主动回应。

　　物理层
　　到底目标服务器后，就会取下 MAC 地址匹配，再取下 IP 头匹配，在传输层的时候，就会对每一个 TCP 请求返回一个成功/失败的简单回应。然后通过 TCP 里面的目标端口号，进行处理。
　　所以 TCP 三次握手的时候，IP 和 MAC 层也是运转了三次，并不止是 TCP 在运作。
　　在网络上运行的包是完整的，可以有下层没有上层，但是绝对不可能有上层没有下层。所以对于 TCP 协议，三次握手或者重试，只要想发出去包，必须有 IP 层和 MAC 层。这样才有目标，才能把包发送出去。
　　当 Buffer 里面的内容完整后，就可以从网口发出去了。
　　二层设备：整个网络包，HTTP、TCP、IP、MAC 都有，并且是匹配 MAC 地址；
　　三层设备：含有 TCP、IP、MAC，匹配 IP ，是对 IP 做丢弃、转发，还是留着。

2、IP 地址
　　公有 IP 到私有 IP，可以举个例子。公有 IP 就是小区，小区名很难有重复（公有IP 不重复）。私有 IP 就是楼号和门牌号。
　　远程定位需要用 IP 定位，局部定位就可以用 MAC 地址。（MAC 地址局限在一个子网里）
　　动态主机配置协议（DHCP - Dynamic Host Configuration Protocol）：自动配置子网 IP 的协议。配置一段共享的IP地址，新接入的机器通过 DHCP 协议就能自动配置 IP。
　　一个新机器，带着唯一的 MAC 地址，使用 IP 地址 0.0.0.0 发送一个广播包，广播包封装在UDP （源端口、目标端口）里，UDP 封装在 BOOTP 里面。目的 IP 地址为 255.255.255.255。DHCP Server 就会分配一个 IP 地址给新机器，并且记录下该 IP，不会再分配给其他 DHCP 客户。

3、物理层到链路层
　　1）、物理层：IP层要封装了 MAC 层才能将包放进物理层。一个集线器，将多台电脑连接起来，没有大脑，完全在物理层工作。将收到的每一个字节，都复制到其他端口上去，这就是第一层物理联调的方案。

　　2）、链路层：也就是 MAC （Medium Access Control），即媒体访问控制。控制往媒体上发数据的时候，谁先发，谁后发，防止混乱。这和 MAC 地址无关。（学名多路访问）

　　有了目标 MAC 地址，数据包在链路上广播，MAC 的网卡才能发现这个包是发送给它的。MAC 拿到包，打开 IP 包，发现 IP 是自己的，再打开 TCP 包，发现端口也是自己的。让后将请求返回结果返回，层层封装，又到达 MAC 层。有源 MAC 层，此时源 MAC 层就成了目标 MAC。

　　3）、交换机
　　交换机学习功能：第一次机器 A 发送求情后，会将 A 记录在网口上。下一次其他机器访问机器 A ，就会直接找到该机器（根据记录的 MAC 地址）。
　　如果应用到交换机层面，假如 A 在交换机左侧，其他机器请求来后，交换机就只会把该广播消息广播到右侧。（最开始广播模式，当应用学习能力，记住了之前的机器MAC 地址，则可以直接调用不用广播）
　　STP 协议：Spanning Tree Protocol ，树状交换。并且通过一些方法选举出根交换机、树枝交换机等。
　　并且交换机很多的情况，可以通过 VLAN 形成虚拟局域网。

4、UDP 协议
　　TCP 三次握手，建立连接，建立一定的数据结构来维护双方的交互状态。提供可靠交付。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。
　　UDP 则继承了 IP 包的特效，不保证不丢失，不保证按顺序到达，是一种无状态的服务。
　　TCP 是面向字节流，UDP 继承 IP 包，基于数据报，一个一个地发，一个一个的收。
　　IP 头里会存一个8位协议，区分数据到底是 TCP 还是 UDP。然后应用程序监听一个端口，用来区分应用程序。这样知道我的数据包是给哪一个应用程序处理。（UDP/TCP 头都应该有端口号）
　　UDP 的使用场景：
　　1）、需要资源比较少，网络情况比较好的内网，或者对包丢失不敏感的应用。
　　2）、不需要一对一沟通，建立连接。而是可以广播的应用。
　　3）、需要处理速度快，延时低，可以容忍少数丢包。小中介
小总结：
　　1）、当网络包到达一个网关的时候，可以用个获取到下一个网关的 IP，虽然可以通过 IP 就获取，但是还是要通过本地的 MAC 地址。
　　原因是：网络包带有源/目标 IP，源/目标 MAC。从路由表获取下一跳的 IP 地址，看起来是 IP 地址，但是其实是通过 ARP 协议得到的 MAC 地址，将下一传送的网关的 MAC 地址放在目标 MAC 地址里面。


##路由，交换，网桥的区别
https://blog.csdn.net/modi000/article/details/80718070

##linux高并发设计
https://blog.csdn.net/u010761477/article/details/83381835

##Nginx + CGI/FastCGI + C/Cpp
https://www.cnblogs.com/skynet/p/4173450.html

##tcp和udp区别
https://www.cnblogs.com/steven520213/p/8005258.html


##iptalbes和netfilter关系
https://segmentfault.com/a/1190000009043962


##linux netfilter 五个钩子点
https://www.cnblogs.com/codestack/p/10850642.html


##网络协议基础知识
https://xz.aliyun.com/t/2531

https://www.cnblogs.com/helloluo/p/7488346.html

##TCP协议包
https://www.cnblogs.com/buxiangxin/p/8336022.html
https://blog.csdn.net/u014590757/article/details/79901948

##TCP拥塞控制，抓包
https://blog.csdn.net/blade2001/article/details/41543297
https://blog.csdn.net/liuruiqun/article/details/50531830
https://blog.csdn.net/weixin_45237113/article/details/92799530

##理解tcp流的相关属性，
https://blog.csdn.net/qq_23100787/article/details/80454398

##tcp连接出现问题的排查方法
https://blog.csdn.net/hguisu/article/details/38700899

## HTTP 断点续传
https://www.cnblogs.com/amyzhu/p/8060451.html

## IO 多路复用
https://www.cnblogs.com/cainingning/p/9556642.html
https://blog.csdn.net/coolgw2015/article/details/79719328
https://www.cnblogs.com/mhq-martin/p/9035640.html

## epoll 和 select 区别
https://www.cnblogs.com/aspirant/p/9166944.html

##多线程下载
https://www.cnblogs.com/carekee/articles/1748815.html
